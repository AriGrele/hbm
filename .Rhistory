new=c()
for(l in 1:length(lefts)){
base=gsub('\\[i\\]','',lefts[l])
new=c(new,paste('y.',lefts[l],'~dnorm(',lefts[l],',tau[',l,'])',sep=''),
paste('y.',base,'.sim[i]~dnorm(',lefts[l],',tau[',l,'])',sep=''),
paste('y.',base,'.res[i]=y.',lefts[l],'-',lefts[l],sep=''),
paste('y.',base,'.sres[i]=y.',base,'.sim[i]-',lefts[l],sep=''))}
row=paste(new,collapse='\n')
middle=paste('for (i in 1:N){',row,'}',sep='\n')
new=c()
for(r in rights){new=c(new,paste(r,'dnorm(0.0,0.01)',sep=' ~ '))}
lower=paste(new,collapse='\n')
bottom=paste('for (j in 1:',
length(lefts),
'){\nsigma[j] ~ dgamma(1,1)\ntau[j] <- pow(sigma[j], -2)\n}\n}',
sep='')
new=c();parameters=c()
for(l in 1:length(lefts)){
base=gsub('\\[i\\]','',lefts[l])
new=c(new,paste('y.',
base,'.fit=sum(pow(y.',base,'.res[],2)/tau[',l,'])',sep=''),
paste('y.',
base,'.sfit=sum(pow(y.',base,'.sres[],2)/tau[',l,'])',sep=''))
parameters=c(parameters,
paste('y.',base,'.sfit',sep=''),
paste('y.',base,'.fit',sep=''))}
tail=paste(new,collapse='\n')
formula=paste(upper,middle,lower,tail,bottom,sep='\n')
sink(paste0(output@dir,'/',output@name,'.jags'))
cat(formula,fill=T)
sink()
output@model_data=list('N'=nrow(output@data))
for(o in unique(old)){output@model_data=c(output@model_data,
setNames(list(output@data[,o]),
paste('y.',o,sep='')))}
inits=function(){list(sigma=rep(1,length(lefts)))}
parameters=c(parameters,c(LETTERS,letters)[1:length(lefts)])
print(output)
output@jags_model=tryCatch(jags(output@model_data,
inits,
parameters,
"model.jags",
n.chains=output@n.chains,
n.thin=output@n.thin,
n.iter=output@n.iter,
n.burnin=output@n.burnin,
parallel=F),
error=function(e){print(e);return(NULL)})
cat('\nMaking trace plots\n')
#traces(output)
return(output)}
semb(data,model)
#################################################################################
semb=function(data,model,...){                                                   #write and compute Bayesian structural equation models, takes arguments of model string, data, directory to save to
output=new('hbm')
param=list(...)
defaults=list('name'        ='unnamed_semb',
'dir'         ='.',
'model_dir'   ='.',
'n.adapt'     =2000,
'n.burnin'    =1000,
'n.iter'      =10000,
'n.thin'      =5,
'n.chains'    =4)
default=c(list('data' =data,
'input'=match.call(expand.dots=T)),
lapply(names(defaults),\(x)ifelse(is.null(param[[x]]),
defaults[[x]],
param[[x]]))|>
setNames(names(defaults)))
for(d in names(default)){
if(class(default[[d]])==class(slot(output,d))){slot(output,d)=default[[d]]}
else{
cat('Invalid input for variable "',d,'"\n',sep='')
return()}}
rows=str_split(model,'\n')[[1]]
row=c();lefts=c();rights=c();old=c()
for(r in 1:length(rows)){
item=c(LETTERS,letters)[r]
rights=c(rights,paste(item,'[1]',sep=''))
groups=str_split(rows[r],'~')[[1]]
left=paste(groups[1],'[i]',sep='')
lefts=c(lefts,left)
old=c(old,groups[1])
Right=str_split(groups[2],'\\+')[[1]]
new=c(paste(item,'[1]',sep=''))
for(i in 1:length(Right)){
old=c(old,Right[i])
new=c(new,paste(item,'[',i+1,']*y.',Right[i],'[i]',sep=''))
rights=c(rights,paste(item,'[',i+1,']',sep=''))}
right=paste(new,collapse=' + ')
row=c(row,paste(left,right,sep=' = '))}
row=paste(row,collapse='\n')
upper=paste('model {\nfor (i in 1:N){',row,'}',sep='\n')
new=c()
for(l in 1:length(lefts)){
base=gsub('\\[i\\]','',lefts[l])
new=c(new,paste('y.',lefts[l],'~dnorm(',lefts[l],',tau[',l,'])',sep=''),
paste('y.',base,'.sim[i]~dnorm(',lefts[l],',tau[',l,'])',sep=''),
paste('y.',base,'.res[i]=y.',lefts[l],'-',lefts[l],sep=''),
paste('y.',base,'.sres[i]=y.',base,'.sim[i]-',lefts[l],sep=''))}
row=paste(new,collapse='\n')
middle=paste('for (i in 1:N){',row,'}',sep='\n')
new=c()
for(r in rights){new=c(new,paste(r,'dnorm(0.0,0.01)',sep=' ~ '))}
lower=paste(new,collapse='\n')
bottom=paste('for (j in 1:',
length(lefts),
'){\nsigma[j] ~ dgamma(1,1)\ntau[j] <- pow(sigma[j], -2)\n}\n}',
sep='')
new=c();parameters=c()
for(l in 1:length(lefts)){
base=gsub('\\[i\\]','',lefts[l])
new=c(new,paste('y.',
base,'.fit=sum(pow(y.',base,'.res[],2)/tau[',l,'])',sep=''),
paste('y.',
base,'.sfit=sum(pow(y.',base,'.sres[],2)/tau[',l,'])',sep=''))
parameters=c(parameters,
paste('y.',base,'.sfit',sep=''),
paste('y.',base,'.fit',sep=''))}
tail=paste(new,collapse='\n')
formula=paste(upper,middle,lower,tail,bottom,sep='\n')
sink(paste0(output@dir,'/',output@name,'.jags'))
cat(formula,fill=T)
sink()
output@model_data=list('N'=nrow(output@data))
for(o in unique(old)){output@model_data=c(output@model_data,
setNames(list(output@data[,o]),
paste('y.',o,sep='')))}
inits=function(){list(sigma=rep(1,length(lefts)))}
parameters=c(parameters,c(LETTERS,letters)[1:length(lefts)])
return(output)
output@jags_model=tryCatch(jags(output@model_data,
inits,
parameters,
"model.jags",
n.chains=output@n.chains,
n.thin=output@n.thin,
n.iter=output@n.iter,
n.burnin=output@n.burnin,
parallel=F),
error=function(e){print(e);return(NULL)})
cat('\nMaking trace plots\n')
#traces(output)
return(output)}
semb(data,model)
model='mass~length+sex
length~sex'
semb(data,model)
#################################################################################
semb=function(data,model,...){                                                   #write and compute Bayesian structural equation models, takes arguments of model string, data, directory to save to
output=new('hbm')
param=list(...)
defaults=list('name'        ='unnamed_semb',
'dir'         ='.',
'model_dir'   ='.',
'n.adapt'     =2000,
'n.burnin'    =1000,
'n.iter'      =10000,
'n.thin'      =5,
'n.chains'    =4)
default=c(list('data' =data,
'input'=match.call(expand.dots=T)),
lapply(names(defaults),\(x)ifelse(is.null(param[[x]]),
defaults[[x]],
param[[x]]))|>
setNames(names(defaults)))
for(d in names(default)){
if(class(default[[d]])==class(slot(output,d))){slot(output,d)=default[[d]]}
else{
cat('Invalid input for variable "',d,'"\n',sep='')
return()}}
rows=str_split(model,'\n')[[1]]
row=c();lefts=c();rights=c();old=c()
for(r in 1:length(rows)){
item=c(LETTERS,letters)[r]
rights=c(rights,paste(item,'[1]',sep=''))
groups=str_split(rows[r],'~')[[1]]
left=paste(groups[1],'[i]',sep='')
lefts=c(lefts,left)
old=c(old,groups[1])
Right=str_split(groups[2],'\\+')[[1]]
new=c(paste(item,'[1]',sep=''))
for(i in 1:length(Right)){
old=c(old,Right[i])
new=c(new,paste(item,'[',i+1,']*y.',Right[i],'[i]',sep=''))
rights=c(rights,paste(item,'[',i+1,']',sep=''))}
right=paste(new,collapse=' + ')
row=c(row,paste(left,right,sep=' = '))}
row=paste(row,collapse='\n')
upper=paste('model {\nfor (i in 1:N){',row,'}',sep='\n')
new=c()
for(l in 1:length(lefts)){
base=gsub('\\[i\\]','',lefts[l])
new=c(new,paste('y.',lefts[l],'~dnorm(',lefts[l],',tau[',l,'])',sep=''),
paste('y.',base,'.sim[i]~dnorm(',lefts[l],',tau[',l,'])',sep=''),
paste('y.',base,'.res[i]=y.',lefts[l],'-',lefts[l],sep=''),
paste('y.',base,'.sres[i]=y.',base,'.sim[i]-',lefts[l],sep=''))}
row=paste(new,collapse='\n')
middle=paste('for (i in 1:N){',row,'}',sep='\n')
new=c()
for(r in rights){new=c(new,paste(r,'dnorm(0.0,0.01)',sep=' ~ '))}
lower=paste(new,collapse='\n')
bottom=paste('for (j in 1:',
length(lefts),
'){\nsigma[j] ~ dgamma(1,1)\ntau[j] <- pow(sigma[j], -2)\n}\n}',
sep='')
new=c();parameters=c()
for(l in 1:length(lefts)){
base=gsub('\\[i\\]','',lefts[l])
new=c(new,paste('y.',
base,'.fit=sum(pow(y.',base,'.res[],2)/tau[',l,'])',sep=''),
paste('y.',
base,'.sfit=sum(pow(y.',base,'.sres[],2)/tau[',l,'])',sep=''))
parameters=c(parameters,
paste('y.',base,'.sfit',sep=''),
paste('y.',base,'.fit',sep=''))}
tail=paste(new,collapse='\n')
formula=paste(upper,middle,lower,tail,bottom,sep='\n')
sink(paste0(output@dir,'/',output@name,'.jags'))
cat(formula,fill=T)
sink()
output@model_data=list('N'=nrow(output@data))
for(o in unique(old)){output@model_data=c(output@model_data,
setNames(list(output@data[,o]),
paste('y.',o,sep='')))}
inits=function(){list(sigma=rep(1,length(lefts)))}
parameters=c(parameters,c(LETTERS,letters)[1:length(lefts)])
output@jags_model=tryCatch(jags(output@model_data,
inits,
parameters,
"model.jags",
n.chains=output@n.chains,
n.thin=output@n.thin,
n.iter=output@n.iter,
n.burnin=output@n.burnin,
parallel=F),
error=function(e){print(e);return(NULL)})
cat('\nMaking trace plots\n')
traces(output)
return(output)}
semb(data,model)
summary(data)
data$sex=as.numeric(data$sex)
model='mass~length+sex
length~sex'
semb(data,model)
#################################################################################
semb=function(data,model,...){                                                   #write and compute Bayesian structural equation models, takes arguments of model string, data, directory to save to
output=new('hbm')
param=list(...)
defaults=list('name'        ='unnamed_semb',
'dir'         ='.',
'model_dir'   ='.',
'n.adapt'     =2000,
'n.burnin'    =1000,
'n.iter'      =10000,
'n.thin'      =5,
'n.chains'    =4)
default=c(list('data' =data,
'input'=match.call(expand.dots=T)),
lapply(names(defaults),\(x)ifelse(is.null(param[[x]]),
defaults[[x]],
param[[x]]))|>
setNames(names(defaults)))
for(d in names(default)){
if(class(default[[d]])==class(slot(output,d))){slot(output,d)=default[[d]]}
else{
cat('Invalid input for variable "',d,'"\n',sep='')
return()}}
rows=str_split(model,'\n')[[1]]
row=c();lefts=c();rights=c();old=c()
for(r in 1:length(rows)){
item=c(LETTERS,letters)[r]
rights=c(rights,paste(item,'[1]',sep=''))
groups=str_split(rows[r],'~')[[1]]
left=paste(groups[1],'[i]',sep='')
lefts=c(lefts,left)
old=c(old,groups[1])
Right=str_split(groups[2],'\\+')[[1]]
new=c(paste(item,'[1]',sep=''))
for(i in 1:length(Right)){
old=c(old,Right[i])
new=c(new,paste(item,'[',i+1,']*y.',Right[i],'[i]',sep=''))
rights=c(rights,paste(item,'[',i+1,']',sep=''))}
right=paste(new,collapse=' + ')
row=c(row,paste(left,right,sep=' = '))}
row=paste(row,collapse='\n')
upper=paste('model {\nfor (i in 1:N){',row,'}',sep='\n')
new=c()
for(l in 1:length(lefts)){
base=gsub('\\[i\\]','',lefts[l])
new=c(new,paste('y.',lefts[l],'~dnorm(',lefts[l],',tau[',l,'])',sep=''),
paste('y.',base,'.sim[i]~dnorm(',lefts[l],',tau[',l,'])',sep=''),
paste('y.',base,'.res[i]=y.',lefts[l],'-',lefts[l],sep=''),
paste('y.',base,'.sres[i]=y.',base,'.sim[i]-',lefts[l],sep=''))}
row=paste(new,collapse='\n')
middle=paste('for (i in 1:N){',row,'}',sep='\n')
new=c()
for(r in rights){new=c(new,paste(r,'dnorm(0.0,0.01)',sep=' ~ '))}
lower=paste(new,collapse='\n')
bottom=paste('for (j in 1:',
length(lefts),
'){\nsigma[j] ~ dgamma(1,1)\ntau[j] <- pow(sigma[j], -2)\n}\n}',
sep='')
new=c();parameters=c()
for(l in 1:length(lefts)){
base=gsub('\\[i\\]','',lefts[l])
new=c(new,paste('y.',
base,'.fit=sum(pow(y.',base,'.res[],2)/tau[',l,'])',sep=''),
paste('y.',
base,'.sfit=sum(pow(y.',base,'.sres[],2)/tau[',l,'])',sep=''))
parameters=c(parameters,
paste('y.',base,'.sfit',sep=''),
paste('y.',base,'.fit',sep=''))}
tail=paste(new,collapse='\n')
formula=paste(upper,middle,lower,tail,bottom,sep='\n')
sink(paste0(output@dir,'/',output@name,'.jags'))
cat(formula,fill=T)
sink()
output@model_data=list('N'=nrow(output@data))
for(o in unique(old)){output@model_data=c(output@model_data,
setNames(list(output@data[,o]),
paste('y.',o,sep='')))}
inits=function(){list(sigma=rep(1,length(lefts)))}
parameters=c(parameters,c(LETTERS,letters)[1:length(lefts)])
output@jags_model=tryCatch(jags(output@model_data,
inits,
parameters,
paste0(output@dir,'/',output@name,'.jags'),
n.chains=output@n.chains,
n.thin=output@n.thin,
n.iter=output@n.iter,
n.burnin=output@n.burnin,
parallel=F),
error=function(e){print(e);return(NULL)})
cat('\nMaking trace plots\n')
traces(output)
return(output)}
semb(data,model)
s=semb(data,model)
fits(s)
#################################################################################
fits=function(mod,...){                                                         #summaries fit measures for Bayesian models, takes arguments of one or more model outputs
mc=match.call(expand.dots=T)
print(mc)
mods=c(list(mod),list(...))
out=data.frame('response'=NA,'ppp'=NA,'DIC'=NA,
'names'=NA,'intercept'=NA,'slope'=NA,'r'=NA)
if(length(mods)>1){
for(m in 1:length(mods)){
mc=gsub('^.+ = ','c(',mc)                                                 #bizarre functionality, if this function breaks it's probably this line
mc=mc[mc!='fits']
new=fits(mods[[m]])
new$names=rep(mc[m],nrow(new))
out=rbind(out,new)}
out=na.omit(out)}
else{
sims=mod$sims.list
groups=c()
for(n in names(sims)){
if(regexpr('\\.s?fit$',n)<=0){sims[[n]]=NULL}
else{groups[n]=gsub('\\.s?fit$','',n)}}
DIC=ifelse(mod$calc.DIC,mod$DIC,'NA')
n=names(groups)
par(mfrow=c(1,ceiling(length(n)/2)))
g=1;for(i in 1:(length(n)/2)){
sims=mod$sims.list
x=sims[[n[g+1]]];y=sims[[n[g]]]
l=lm(y~x)
out=rbind(out,data.frame('response'=groups[n[g]],
'ppp'=pp.check(mod,n[g+1],n[g]),
'DIC'=DIC,'names'='model','intercept'=coef(l)[1],
'slope'=coef(l)[2],r=summary(l)$r.squared))
g=g+2}
par(mfrow=c(1,1))}
return(na.omit(out))}
fits(s)
fits(s,s)
fits(s@jags_model)
fits(s@jags_model,s@jags_model)
#################################################################################
fits=function(hbm,...){                                                         #summaries fit measures for Bayesian models, takes arguments of one or more model outputs
mc=match.call(expand.dots=T)
print(mc)
mods=c(list(hbm@jags_model),list(...))
out=data.frame('response'=NA,'ppp'=NA,'DIC'=NA,
'names'=NA,'intercept'=NA,'slope'=NA,'r'=NA)
if(length(mods)>1){
for(m in 1:length(mods)){
mc=gsub('^.+ = ','c(',mc)                                                 #bizarre functionality, if this function breaks it's probably this line
mc=mc[mc!='fits']
new=fits(mods[[m]])
new$names=rep(mc[m],nrow(new))
out=rbind(out,new)}
out=na.omit(out)}
else{
sims=hbm@jags_model$sims.list
groups=c()
for(n in names(sims)){
if(regexpr('\\.s?fit$',n)<=0){sims[[n]]=NULL}
else{groups[n]=gsub('\\.s?fit$','',n)}}
DIC=ifelse(hbm@jags_model$calc.DIC,hbm@jags_model$DIC,'NA')
n=names(groups)
par(mfrow=c(1,ceiling(length(n)/2)))
g=1;for(i in 1:(length(n)/2)){
sims=hbm@jags_model$sims.list
x=sims[[n[g+1]]];y=sims[[n[g]]]
l=lm(y~x)
out=rbind(out,data.frame('response'=groups[n[g]],
'ppp'=pp.check(mod,n[g+1],n[g]),
'DIC'=DIC,'names'='model','intercept'=coef(l)[1],
'slope'=coef(l)[2],r=summary(l)$r.squared))
g=g+2}
par(mfrow=c(1,1))}
return(na.omit(out))}
fits(s)
#################################################################################
fits=function(hbm,...){                                                         #summaries fit measures for Bayesian models, takes arguments of one or more model outputs
mc=match.call(expand.dots=T)
print(mc)
mods=c(list(hbm@jags_model),list(...))
out=data.frame('response'=NA,'ppp'=NA,'DIC'=NA,
'names'=NA,'intercept'=NA,'slope'=NA,'r'=NA)
if(length(mods)>1){
for(m in 1:length(mods)){
mc=gsub('^.+ = ','c(',mc)                                                 #bizarre functionality, if this function breaks it's probably this line
mc=mc[mc!='fits']
new=fits(mods[[m]])
new$names=rep(mc[m],nrow(new))
out=rbind(out,new)}
out=na.omit(out)}
else{
sims=hbm@jags_model$sims.list
groups=c()
for(n in names(sims)){
if(regexpr('\\.s?fit$',n)<=0){sims[[n]]=NULL}
else{groups[n]=gsub('\\.s?fit$','',n)}}
DIC=ifelse(hbm@jags_model$calc.DIC,hbm@jags_model$DIC,'NA')
n=names(groups)
par(mfrow=c(1,ceiling(length(n)/2)))
g=1;for(i in 1:(length(n)/2)){
sims=hbm@jags_model$sims.list
x=sims[[n[g+1]]];y=sims[[n[g]]]
l=lm(y~x)
out=rbind(out,data.frame('response'=groups[n[g]],
'ppp'=pp.check(hbm@jags_model,n[g+1],n[g]),
'DIC'=DIC,'names'='model','intercept'=coef(l)[1],
'slope'=coef(l)[2],r=summary(l)$r.squared))
g=g+2}
par(mfrow=c(1,1))}
return(na.omit(out))}
fits(s)
fits(s,s)
#################################################################################
fits=function(hbm,...){                                                         #summaries fit measures for Bayesian models, takes arguments of one or more model outputs
mc=match.call(expand.dots=T)
print(mc)
mods=c(list(hbm),list(...))
out=data.frame('response'=NA,'ppp'=NA,'DIC'=NA,
'names'=NA,'intercept'=NA,'slope'=NA,'r'=NA)
if(length(mods)>1){
for(m in 1:length(mods)){
mc=gsub('^.+ = ','c(',mc)                                                 #bizarre functionality, if this function breaks it's probably this line
mc=mc[mc!='fits']
new=fits(mods[[m]])
new$names=rep(mc[m],nrow(new))
out=rbind(out,new)}
out=na.omit(out)}
else{
sims=hbm@jags_model$sims.list
groups=c()
for(n in names(sims)){
if(regexpr('\\.s?fit$',n)<=0){sims[[n]]=NULL}
else{groups[n]=gsub('\\.s?fit$','',n)}}
DIC=ifelse(hbm@jags_model$calc.DIC,hbm@jags_model$DIC,'NA')
n=names(groups)
par(mfrow=c(1,ceiling(length(n)/2)))
g=1;for(i in 1:(length(n)/2)){
sims=hbm@jags_model$sims.list
x=sims[[n[g+1]]];y=sims[[n[g]]]
l=lm(y~x)
out=rbind(out,data.frame('response'=groups[n[g]],
'ppp'=pp.check(hbm@jags_model,n[g+1],n[g]),
'DIC'=DIC,'names'='model','intercept'=coef(l)[1],
'slope'=coef(l)[2],r=summary(l)$r.squared))
g=g+2}
par(mfrow=c(1,1))}
return(na.omit(out))}
fits(s,s)
ddic(fits(s))
#################################################################################
ddic=function(mod){                                                             #compares model fits, DIC for bsems, takes argument of frame of fit outputs
if(class(mod)!='data.frame'){cat('Not output of fits()\n')}
else{
if(length(unique(mod$names))<2){cat('Only one model input\n')}
dics=unique(mod$DIC)
n=unique(mod$names)
out=data.frame('name'=NA,'delta_DIC'=NA)
used=c()
for(i in 1:length(n)){
used=c(used,i)
for(j in 1:length(dics)){
if(i!=j&!(j %in% used)){
out=rbind(out,data.frame('name'=paste(n[i],n[j],sep=' - '),
'delta_DIC'=dics[i]-dics[j]))}}}
return(na.omit(out))}}
ddic(fits(s))
ddic(fits(s),fits(s))
ddic(fits(s,s))
b=semb(data,model)
ddic(fits(s,b))
